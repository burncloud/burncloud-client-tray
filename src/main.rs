use systray::Application;
use std::process;
use std::fmt;

#[derive(Debug)]
struct SimpleError(String);

impl fmt::Display for SimpleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl std::error::Error for SimpleError {}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut app = Application::new()?;

    let mut ico = "./wei.ico";
    let mut path = std::env::current_dir()?;
    path.push("./src/main.rs");
    if path.exists() {
        // 确保res目录存在
        let res_dir = std::path::Path::new("./res");
        if !res_dir.exists() {
            std::fs::create_dir_all(res_dir)?;
        }
        ico = "./res/wei.ico";
    }

    let ico_path = std::path::Path::new(ico);

    // 如果ico文件不存在，创建一个默认的ico文件
    if !ico_path.exists() {
        create_default_ico(ico_path)?;
    }

    // 尝试设置图标，如果失败则使用默认方式
    match app.set_icon_from_file(&ico_path.to_string_lossy()) {
        Ok(_) => {},
        Err(_) => {
            // 如果设置图标失败，尝试不设置图标或使用系统默认图标
            println!("Warning: Failed to set custom icon, using default");
        }
    }

    // 添加启动界面菜单项
    app.add_menu_item(&"启动界面".to_string(), |_| -> Result<(), SimpleError> {
        if let Err(e) = webbrowser::open("http://127.0.0.1:8080") {
            eprintln!("Failed to open browser: {}", e);
        }
        Ok(())
    })?;

    // 添加分隔符
    app.add_menu_separator()?;

    // 添加退出菜单项
    app.add_menu_item(&"退出程序".to_string(), |_| -> Result<(), SimpleError> {
        process::exit(0);
    })?;

    // 等待
    app.wait_for_message()?;

    Ok(())
}

fn create_default_ico(ico_path: &std::path::Path) -> Result<(), Box<dyn std::error::Error>> {
    // 创建一个简单的16x16像素的ICO文件数据
    let ico_data = [
        0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x10, 0x10, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x28, 0x01,
        0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x00,
        0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x80, 0x80,
        0x80, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00,
        0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x77, 0x77,
        0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
        0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
        0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
        0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    std::fs::write(ico_path, &ico_data)?;
    Ok(())
}